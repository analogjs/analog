/* eslint-disable */
// @ts-nocheck
// noinspection JSUnusedGlobalSymbols

// This file is auto-generated by @analogjs/vite-plugin-angular
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { Component } from '@angular/core'
import { Routes } from '@angular/router'
import type { Route } from '@angular/router'
import type { WithContext, Thing } from 'schema-dts'

import { routeMeta as IndexRouteMeta } from './pages/(home).page'
import { routeMeta as ArticleRouteMeta } from './pages/article.page'
import { routeJsonLd as ArticleJsonLd } from './pages/article.page'
import { routeJsonLd as EventJsonLd } from './pages/event.page'
import { routeJsonLd as ProductJsonLd } from './pages/product.page'
import { routeMeta as TestMetaRouteMeta } from './pages/test-meta.page'
import { routeMeta as ServerServerRouteMeta } from './pages/server/(server).page'

const IndexRoute: Route = {
  path: '',
  loadComponent: () => import('./pages/(home).page').then(m => m.default),
  data: { hasRouteMeta: true, routePath: './pages/(home).page' }
}
const CatchAllRoute: Route = {
  path: '/**',
  loadComponent: () => import('./pages/[...slug].page').then(m => m.default)
}
const ArticleRoute: Route = {
  path: '/article',
  loadComponent: () => import('./pages/article.page').then(m => m.default),
  data: { hasRouteMeta: true, routePath: './pages/article.page' }
}
const AuthRoute: Route = {
  path: '/auth',
  loadComponent: () => import('./pages/(auth).page').then(m => m.default)
}
const CartRoute: Route = {
  path: '/cart',
  loadComponent: () => import('./pages/cart.page').then(m => m.default)
}
const EventRoute: Route = {
  path: '/event',
  loadComponent: () => import('./pages/event.page').then(m => m.default)
}
const GoodbyeRoute: Route = {
  path: '/goodbye',
  loadComponent: () => import('./pages/goodbye.page').then(m => m.default)
}
const NewsletterRoute: Route = {
  path: '/newsletter',
  loadComponent: () => import('./pages/newsletter.page').then(m => m.default)
}
const PackageRoute: Route = {
  path: '/package',
  loadComponent: () => import('./pages/package.page').then(m => m.default)
}
const ProductRoute: Route = {
  path: '/product',
  loadComponent: () => import('./pages/product.page').then(m => m.default)
}
const SearchRoute: Route = {
  path: '/search',
  loadComponent: () => import('./pages/search.page').then(m => m.default)
}
const TestMetaRoute: Route = {
  path: '/test-meta',
  loadComponent: () => import('./pages/test-meta.page').then(m => m.default),
  data: { hasRouteMeta: true, routePath: './pages/test-meta.page' }
}
const AuthSignUpRoute: Route = {
  path: '/(auth)/sign-up',
  loadComponent: () => import('./pages/(auth)/sign-up.page').then(m => m.default)
}
const ClientClientRoute: Route = {
  path: '/client/(client)',
  loadComponent: () => import('./pages/client/(client).page').then(m => m.default)
}
const ProductsProductIdRoute: Route = {
  path: '/products/:productId',
  loadComponent: () => import('./pages/products.[productId].page').then(m => m.default)
}
const ServerServerRoute: Route = {
  path: '/server/(server)',
  loadComponent: () => import('./pages/server/(server).page').then(m => m.default),
  data: { hasRouteMeta: true, routePath: './pages/server/(server).page' }
}
const ShippingCatchAllRoute: Route = {
  path: '/shipping/**',
  loadComponent: () => import('./pages/shipping/[...slug].page').then(m => m.default)
}
const ShippingIndexRoute: Route = {
  path: '/shipping/index',
  loadComponent: () => import('./pages/shipping/index.page').then(m => m.default)
}


export interface FileRoutesByPath {
  '/': Route,
  '/**': Route,
  '/article': Route,
  '/auth': Route,
  '/cart': Route,
  '/event': Route,
  '/goodbye': Route,
  '/newsletter': Route,
  '/package': Route,
  '/product': Route,
  '/search': Route,
  '/test-meta': Route,
  '/(auth)/sign-up': Route,
  '/client/(client)': Route,
  '/products/:productId': Route,
  '/server/(server)': Route,
  '/shipping/**': Route,
  '/shipping/index': Route
}

export interface FileRoutesByTo {
  '/': Route,
  '/**': Route,
  '/article': Route,
  '/auth': Route,
  '/cart': Route,
  '/event': Route,
  '/goodbye': Route,
  '/newsletter': Route,
  '/package': Route,
  '/product': Route,
  '/search': Route,
  '/test-meta': Route,
  '/(auth)/sign-up': Route,
  '/client/(client)': Route,
  '/products/:productId': Route,
  '/server/(server)': Route,
  '/shipping/**': Route,
  '/shipping/index': Route
}

export interface FileRoutesById {
  '/': Route,
  '/**': Route,
  '/article': Route,
  '/auth': Route,
  '/cart': Route,
  '/event': Route,
  '/goodbye': Route,
  '/newsletter': Route,
  '/package': Route,
  '/product': Route,
  '/search': Route,
  '/test-meta': Route,
  '/(auth)/sign-up': Route,
  '/client/(client)': Route,
  '/products/:productId': Route,
  '/server/(server)': Route,
  '/shipping/**': Route,
  '/shipping/index': Route
}

export interface FileRouteTypes {
  fileRoutesByPath: FileRoutesByPath
  fullPaths: '/' | '/**' | '/article' | '/auth' | '/cart' | '/event' | '/goodbye' | '/newsletter' | '/package' | '/product' | '/search' | '/test-meta' | '/(auth)/sign-up' | '/client/(client)' | '/products/:productId' | '/server/(server)' | '/shipping/**' | '/shipping/index'
  fileRoutesByTo: FileRoutesByTo
  to: '/' | '/**' | '/article' | '/auth' | '/cart' | '/event' | '/goodbye' | '/newsletter' | '/package' | '/product' | '/search' | '/test-meta' | '/(auth)/sign-up' | '/client/(client)' | '/products/:productId' | '/server/(server)' | '/shipping/**' | '/shipping/index'
  id: '/' | '/**' | '/article' | '/auth' | '/cart' | '/event' | '/goodbye' | '/newsletter' | '/package' | '/product' | '/search' | '/test-meta' | '/(auth)/sign-up' | '/client/(client)' | '/products/:productId' | '/server/(server)' | '/shipping/**' | '/shipping/index'
  fileRoutesById: FileRoutesById
}

export interface RootRouteChildren {
  IndexRoute: Route,
  CatchAllRoute: Route,
  ArticleRoute: Route,
  AuthRoute: Route,
  CartRoute: Route,
  EventRoute: Route,
  GoodbyeRoute: Route,
  NewsletterRoute: Route,
  PackageRoute: Route,
  ProductRoute: Route,
  SearchRoute: Route,
  TestMetaRoute: Route,
  ProductsProductIdRoute: Route
}

// Angular Router lazy loading routes
export const angularRoutes: Routes = [
  IndexRoute,
  CatchAllRoute,
  ArticleRoute,
  AuthRoute,
  CartRoute,
  EventRoute,
  GoodbyeRoute,
  NewsletterRoute,
  PackageRoute,
  ProductRoute,
  SearchRoute,
  TestMetaRoute,
  ProductsProductIdRoute
]

const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  CatchAllRoute: CatchAllRoute,
  ArticleRoute: ArticleRoute,
  AuthRoute: AuthRoute,
  CartRoute: CartRoute,
  EventRoute: EventRoute,
  GoodbyeRoute: GoodbyeRoute,
  NewsletterRoute: NewsletterRoute,
  PackageRoute: PackageRoute,
  ProductRoute: ProductRoute,
  SearchRoute: SearchRoute,
  TestMetaRoute: TestMetaRoute,
  ProductsProductIdRoute: ProductsProductIdRoute
}

export const routeTree = rootRouteChildren

// Map of routes to their JSON-LD data
export const routeJsonLdMap = new Map<string, any>([
  ['/article', ArticleJsonLd],
  ['/event', EventJsonLd],
  ['/product', ProductJsonLd]
])

// Type for Angular Route metadata (excludes file-based properties)
export type RouteMeta = Omit<Route, 'component' | 'loadComponent' | 'loadChildren' | 'path' | 'pathMatch'>

// Type for JSON-LD structured data
export type JsonLd = WithContext<Thing>

declare module '@analogjs/router' {
  interface FileRoutesByPath {
    '/': {
      id: '/'
      path: '/'
      fullPath: '/'
      component: typeof IndexComponent
      routeMeta: typeof IndexRouteMeta
      parentRoute: typeof rootRoute
    }
    '/**': {
      id: '/**'
      path: '/**'
      fullPath: '/**'
      component: typeof CatchAllComponent
      parentRoute: typeof rootRoute
    }
    '/article': {
      id: '/article'
      path: '/article'
      fullPath: '/article'
      component: typeof ArticleComponent
      routeMeta: typeof ArticleRouteMeta
      jsonLd: typeof ArticleJsonLd
      parentRoute: typeof rootRoute
    }
    '/auth': {
      id: '/auth'
      path: '/auth'
      fullPath: '/auth'
      component: typeof AuthComponent
      parentRoute: typeof rootRoute
    }
    '/cart': {
      id: '/cart'
      path: '/cart'
      fullPath: '/cart'
      component: typeof CartComponent
      parentRoute: typeof rootRoute
    }
    '/event': {
      id: '/event'
      path: '/event'
      fullPath: '/event'
      component: typeof EventComponent
      jsonLd: typeof EventJsonLd
      parentRoute: typeof rootRoute
    }
    '/goodbye': {
      id: '/goodbye'
      path: '/goodbye'
      fullPath: '/goodbye'
      component: typeof GoodbyeComponent
      parentRoute: typeof rootRoute
    }
    '/newsletter': {
      id: '/newsletter'
      path: '/newsletter'
      fullPath: '/newsletter'
      component: typeof NewsletterComponent
      parentRoute: typeof rootRoute
    }
    '/package': {
      id: '/package'
      path: '/package'
      fullPath: '/package'
      component: typeof PackageComponent
      parentRoute: typeof rootRoute
    }
    '/product': {
      id: '/product'
      path: '/product'
      fullPath: '/product'
      component: typeof ProductComponent
      jsonLd: typeof ProductJsonLd
      parentRoute: typeof rootRoute
    }
    '/search': {
      id: '/search'
      path: '/search'
      fullPath: '/search'
      component: typeof SearchComponent
      parentRoute: typeof rootRoute
    }
    '/test-meta': {
      id: '/test-meta'
      path: '/test-meta'
      fullPath: '/test-meta'
      component: typeof TestMetaComponent
      routeMeta: typeof TestMetaRouteMeta
      parentRoute: typeof rootRoute
    }
    '/(auth)/sign-up': {
      id: '/(auth)/sign-up'
      path: '/(auth)/sign-up'
      fullPath: '/(auth)/sign-up'
      component: typeof AuthSignUpComponent
      parentRoute: typeof rootRoute
    }
    '/client/(client)': {
      id: '/client/(client)'
      path: '/client/(client)'
      fullPath: '/client/(client)'
      component: typeof ClientClientComponent
      parentRoute: typeof rootRoute
    }
    '/products/:productId': {
      id: '/products/:productId'
      path: '/products/:productId'
      fullPath: '/products/:productId'
      component: typeof ProductsProductIdComponent
      parentRoute: typeof rootRoute
    }
    '/server/(server)': {
      id: '/server/(server)'
      path: '/server/(server)'
      fullPath: '/server/(server)'
      component: typeof ServerServerComponent
      routeMeta: typeof ServerServerRouteMeta
      parentRoute: typeof rootRoute
    }
    '/shipping/**': {
      id: '/shipping/**'
      path: '/shipping/**'
      fullPath: '/shipping/**'
      component: typeof ShippingCatchAllComponent
      parentRoute: typeof rootRoute
    }
    '/shipping/index': {
      id: '/shipping/index'
      path: '/shipping/index'
      fullPath: '/shipping/index'
      component: typeof ShippingIndexComponent
      parentRoute: typeof rootRoute
    }
  }
}

// Utility types for type-safe navigation
export type AnalogRoute = keyof FileRoutesByPath

// Extract route params from path
export type ExtractParams<T extends string> =
  T extends `${string}/:${infer Param}/${infer Rest}`
    ? { [K in Param]: string } & ExtractParams<`/${Rest}`>
    : T extends `${string}/:${infer Param}`
    ? { [K in Param]: string }
    : {}

export type RouteParams<T extends AnalogRoute> = ExtractParams<T>

// Type-safe navigation utilities
export function navigateToRoute<T extends AnalogRoute>(
  router: any, // Router from '@angular/router'
  route: T,
  params?: RouteParams<T>,
  options?: any // NavigationExtras
): Promise<boolean> {
  return router.navigate([route], {
    ...options,
    ...(params && { queryParams: params })
  })
}

// Type-safe route checking
export function isCurrentRoute<T extends AnalogRoute>(
  router: any, // Router from '@angular/router'
  route: T
): boolean {
  return router.url === route
}

// Get route with params
export function getRouteWithParams<T extends AnalogRoute>(
  route: T,
  params: RouteParams<T>
): string {
  let result = route as string
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      result = result.replace(`:${key}`, String(value))
    })
  }
  return result
}
