/**
 * Type generator for type-safe routing.
 * Generates TypeScript declaration content from parsed routes.
 */

import type { ParsedRoute } from './route-parser.js';

/**
 * Generates the TypeScript declaration file content for type-safe routing.
 * Output is deterministic (sorted alphabetically) for consistent version control.
 */
export function generateRouteTypes(routes: ParsedRoute[]): string {
  const staticRoutes = routes.filter((r) => r.isStatic);
  const dynamicRoutes = routes.filter((r) => !r.isStatic);

  // Build static routes type
  const staticRoutesType =
    staticRoutes.length > 0
      ? staticRoutes.map((r) => `    | '${r.typedPath}'`).join('\n')
      : '    | never';

  // Build dynamic route params interface
  const dynamicRouteParamsEntries = dynamicRoutes
    .map((r) => {
      const paramsType = r.params
        .map((p) => `'${p}': string | number`)
        .join('; ');
      return `    '${r.typedPath}': { ${paramsType} };`;
    })
    .join('\n');

  // Build resolved route params interface (runtime values are always strings)
  const resolvedRouteParamsEntries = dynamicRoutes
    .map((r) => {
      const paramsType = r.params.map((p) => `'${p}': string`).join('; ');
      return `    '${r.typedPath}': { ${paramsType} };`;
    })
    .join('\n');

  // Handle empty dynamic routes
  const dynamicRouteParamsContent =
    dynamicRoutes.length > 0
      ? dynamicRouteParamsEntries
      : '    [key: string]: never;';

  const resolvedRouteParamsContent =
    dynamicRoutes.length > 0
      ? resolvedRouteParamsEntries
      : '    [key: string]: never;';

  return `/**
 * Auto-generated by @analogjs/platform
 * Run \`npm run dev\` or \`npm run build\` to regenerate.
 * DO NOT EDIT MANUALLY
 */

import type { Signal } from '@angular/core';
import type { NavigationExtras, NavigationBehaviorOptions } from '@angular/router';
import type { TypeConstructor, InferConstructor, SchemaLike, InferSchemaOutput } from '@analogjs/router';

declare module '@analogjs/router' {
  /** Static routes (no parameters required) */
  export type StaticRoutes =
${staticRoutesType};

  /** Dynamic route parameter types (for building routes) */
  export interface DynamicRouteParams {
${dynamicRouteParamsContent}
  }

  /** Resolved parameter types (runtime values are strings) */
  export interface ResolvedRouteParams {
${resolvedRouteParamsContent}
  }

  /** Dynamic routes (parameters required) */
  export type DynamicRoutes = keyof DynamicRouteParams;

  /** All valid application routes */
  export type TypedRoutes = StaticRoutes | DynamicRoutes;

  /**
   * Override the base TypedRoute to allow valid routes.
   * The base package uses 'never' to force generation of this file.
   */
  export type TypedRoute = TypedRoutes;

  /** Extract parameter type for building a route */
  export type RouteParams<T extends DynamicRoutes> = DynamicRouteParams[T];

  /** Extract resolved parameter type for consuming route params */
  export type ResolvedParams<T extends DynamicRoutes> = ResolvedRouteParams[T];

  /** Build a typed route path */
  export function route<T extends StaticRoutes>(path: T): T;
  export function route<T extends DynamicRoutes>(
    path: T,
    params: DynamicRouteParams[T]
  ): string;

  /** Type-safe navigation (wrapper for Router.navigate) */
  export function navigate<T extends StaticRoutes>(
    path: T,
    params?: undefined,
    extras?: NavigationExtras
  ): Promise<boolean>;
  export function navigate<T extends DynamicRoutes>(
    path: T,
    params: DynamicRouteParams[T],
    extras?: NavigationExtras
  ): Promise<boolean>;

  /** Type-safe URL navigation (wrapper for Router.navigateByUrl) */
  export function navigateByUrl<T extends StaticRoutes>(
    path: T,
    params?: undefined,
    extras?: NavigationBehaviorOptions
  ): Promise<boolean>;
  export function navigateByUrl<T extends DynamicRoutes>(
    path: T,
    params: DynamicRouteParams[T],
    extras?: NavigationBehaviorOptions
  ): Promise<boolean>;

  /** Inject typed route params as a Signal */
  export function injectParams<T extends DynamicRoutes>(): Signal<ResolvedRouteParams[T]>;

  /** Inject typed route params with schema override */
  export function injectParams<
    T extends DynamicRoutes,
    S extends { [K in keyof ResolvedRouteParams[T]]?: TypeConstructor } | SchemaLike<unknown>
  >(
    schema: S
  ): Signal<
    S extends SchemaLike<unknown>
      ? InferSchemaOutput<S>
      : {
          [K in keyof ResolvedRouteParams[T]]: K extends keyof S
            ? S[K] extends TypeConstructor
              ? InferConstructor<S[K]>
              : string
            : string;
        }
  >;
}
`;
}
