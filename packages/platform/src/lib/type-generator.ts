/**
 * Type generator for type-safe routing.
 * Generates TypeScript declaration content from parsed routes.
 */

import type { ParsedRoute } from './route-parser.js';

/**
 * Generates the TypeScript declaration file content for type-safe routing.
 * Output is deterministic (sorted alphabetically) for consistent version control.
 */
export function generateRouteTypes(routes: ParsedRoute[]): string {
  const staticRoutes = routes.filter((r) => r.isStatic);
  const dynamicRoutes = routes.filter((r) => !r.isStatic);

  // Build static routes type
  const staticRoutesType =
    staticRoutes.length > 0
      ? staticRoutes.map((r) => `    | '${r.typedPath}'`).join('\n')
      : '    | never';

  // Build dynamic route params interface
  const dynamicRouteParamsEntries = dynamicRoutes
    .map((r) => {
      const paramsType = r.params
        .map((p) => `'${p}': string | number`)
        .join('; ');
      return `    '${r.typedPath}': { ${paramsType} };`;
    })
    .join('\n');

  // Build resolved route params interface (runtime values are always strings)
  const resolvedRouteParamsEntries = dynamicRoutes
    .map((r) => {
      const paramsType = r.params.map((p) => `'${p}': string`).join('; ');
      return `    '${r.typedPath}': { ${paramsType} };`;
    })
    .join('\n');

  // Handle empty dynamic routes
  const dynamicRouteParamsContent =
    dynamicRoutes.length > 0
      ? dynamicRouteParamsEntries
      : '    [key: string]: never;';

  const resolvedRouteParamsContent =
    dynamicRoutes.length > 0
      ? resolvedRouteParamsEntries
      : '    [key: string]: never;';

  return `/**
 * Auto-generated by @analogjs/platform
 * Run \`npm run dev\` or \`npm run build\` to regenerate.
 * DO NOT EDIT MANUALLY
 */

import type { NavigationExtras, NavigationBehaviorOptions } from '@angular/router';

declare module '@analogjs/router' {
  /** Static routes (no parameters required) */
  export type StaticRoutes =
${staticRoutesType};

  /** Dynamic route parameter types (for building routes) */
  export interface DynamicRouteParams {
${dynamicRouteParamsContent}
  }

  /**
   * Augment ResolvedRouteParams with application routes.
   * This interface is merged with the empty base interface from @analogjs/router.
   * The base package's injectParams function uses this to provide type-safe params.
   */
  export interface ResolvedRouteParams {
${resolvedRouteParamsContent}
  }

  /** All valid application routes */
  export type TypedRoutes = StaticRoutes | keyof DynamicRouteParams;

  /** Override the base TypedRoute to allow valid routes */
  export type TypedRoute = TypedRoutes;

  /** Extract parameter type for building a route */
  export type RouteParams<T extends keyof DynamicRouteParams> = DynamicRouteParams[T];

  /** Extract resolved parameter type for consuming route params */
  export type ResolvedParams<T extends keyof ResolvedRouteParams> = ResolvedRouteParams[T];

  /** Build a typed route path */
  export function route<T extends StaticRoutes>(path: T): T;
  export function route<T extends keyof DynamicRouteParams>(
    path: T,
    params: DynamicRouteParams[T]
  ): string;

  /** Type-safe navigation (wrapper for Router.navigate) */
  export function navigate<T extends StaticRoutes>(
    path: T,
    params?: undefined,
    extras?: NavigationExtras
  ): Promise<boolean>;
  export function navigate<T extends keyof DynamicRouteParams>(
    path: T,
    params: DynamicRouteParams[T],
    extras?: NavigationExtras
  ): Promise<boolean>;

  /** Type-safe URL navigation (wrapper for Router.navigateByUrl) */
  export function navigateByUrl<T extends StaticRoutes>(
    path: T,
    params?: undefined,
    extras?: NavigationBehaviorOptions
  ): Promise<boolean>;
  export function navigateByUrl<T extends keyof DynamicRouteParams>(
    path: T,
    params: DynamicRouteParams[T],
    extras?: NavigationBehaviorOptions
  ): Promise<boolean>;
}
`;
}
